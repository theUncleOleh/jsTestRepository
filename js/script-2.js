// Модуль 2

// задача 1

// Ранний возврат
// В функции может быть больше одного оператора return. Главное помнить, что выполнение функции прерывается когда интерпретатор встречает возврат, и весь код после него будет проигнорирован в текущем вызове функции.

// Возьмём уже знакомую нам функцию проверки совершеннолетия. Она работает, но здесь есть «лишний» код, то есть тело функции можно оптимизировать. В данном случае подойдёт приём (паттерн) «ранний возврат».

// function checkAge(age) {
//   let message;

//   if (age >= 18) {
//     message = 'Вы совершеннолетний человек';
//   } else {
//     message = 'Вы не совершеннолетний человек';
//   }

//   return message;
// }
// Если условие в if выполняется, то есть приводится к true, возвращаем строку 'Вы совершеннолетний человек' и код ниже уже не исполнится.
// Если условие в if не выполняется, то есть приводится к false, возвращаем строку 'Вы не совершеннолетний человек'.
// Используя паттерн «ранний возврат» и то, что выполнение функции прерывается на операторе return, мы избавляемся от лишней переменной и блока else. То есть этот приём помогает «разгладить» ветвления.



// function checkAge(age) {
//   if (age >= 18) { // Дополни эту строку
//     return 'Вы совершеннолетний человек';
//   }

//   return 'Вы не совершеннолетний человек';
// }


// задача 2

// Проверка пароля (ранний возврат)

// Задание
// Функция checkPassword получает пароль пользователя в параметр password, проверяет его на совпадение с паролем администратора в переменной ADMIN_PASSWORD и возвращает сообщение о результате сравнения.

// Проведи рефакторинг кода функции checkStorage используя паттерн «ранний возврат»:

// удали переменную message;
// удали else;
// код должен работать так же, как и до оптимизации.

// function checkPassword(password) {
//   const ADMIN_PASSWORD = 'jqueryismyjam';
//   // Пиши код ниже этой строки
 

//   if (password === ADMIN_PASSWORD) {
//     return 'Добро пожаловать!';
//   } 
//     return 'Доступ запрещен, неверный пароль!';
  

 
//   // Пиши код выше этой строки
// }





// function checkPassword(password) {
//   password = prompt('Введите пожалуйста пароль') ;

//   const ADMIN_PASSWORD = 'jqueryismyjam';
//   // Пиши код ниже этой строки
//   let message 

//   if (password === ADMIN_PASSWORD) {
//     message = 'Добро пожаловать!';
//   } else {
//     message = 'Доступ запрещен, неверный пароль!';
//   }

//   return message;
//   // Пиши код выше этой строки
// }

// console.log(checkPassword());


// задача 3

// Склад товаров 3.0
// Функция checkStorage проверяет возможность оформления заказа и возвращает сообщение о результате. Она принимает два параметра, значения которых будут задаваться во время её вызова.

// available - доступное количество товаров на складе;
// ordered - количество единиц товара в заказе.
// Проведи рефакторинг кода функции checkStorage используя паттерн «ранний возврат».

// function checkStorage(available, ordered) {
  // Пиши код ниже этой строки
  

//   if (ordered === 0) {
//     return 'В заказе еще нет товаров';
//   }  if (ordered > available) {
//     return 'Слишком большой заказ, на складе недостаточно товаров!';
//   }  
//     return 'Заказ оформлен, с вами свяжется менеджер';
  

  
//   // Пиши код выше этой строки
// }
// console.log(checkStorage(100, 50)) ;


// задача 4

// Создание массива

// Массив используется для хранения упорядоченной коллекции элементов. Он объявляется открывающей и закрывающей квадратной скобками [] - литералом массива. Внутри скобок каждый элемент массива разделяется запятой.

// const planets = ['Земля', 'Марс', 'Венера'];
// Полезно
// При объявлении переменной для объекта или массива программисты обычно используют const. Они делают это для того, чтобы случайно не перезаписать значение, т.к. попытка перезаписи вызовет ошибку до того как код попадет к пользователю.


// const fruits = ['яблоко','слива','груша','апельсин'];


// задача 5

// Доступ к элементам по индексу

// Для доступа к значению элемента массива применяют синтаксис квадратных скобок массив[индекс]. Между именем переменной массива и квадратными скобками не должно быть пробела.


// // Стартовый код
// const fruits = ['яблоко', 'слива', 'груша', 'апельсин'];
// // Пиши код ниже этой строки
// const firstElement = fruits[0];
// const secondElement = fruits[1];
// const lastElement = fruits[3];


// задача 6

// Переопределение значения элемента

// В отличии от строк, элементы массива можно изменять обратившись к ним по индексу и присвоив другое значение.

// const numbers = [1, 2, 3, 4, 5];
// numbers[0] = 7;
// numbers[2] = 14;
// console.log(numbers); // [7, 2, 14, 4, 5];

// // Стартовый код
// const fruits = ['яблоко', 'слива', 'груша', 'апельсин'];
// // Пиши код ниже этой строки

// fruits[1] = 'персик' ;
// fruits[3] = 'банан';

// задача 7

// Длина массива

// Длина массива, то есть число его элементов, хранится в свойстве length. Это динамическая величина, которая изменяется автоматически при добавлении или удалении элементов.

// // Стартовый код
// const fruits = ['яблоко', 'персик', 'груша', 'банан'];
// // Пиши код ниже этой строки

// const fruitsArrayLength = fruits.length;

// задача 8

// Индекс последнего элемента

// Чаще всего, мы заранее в коде не знаем какая будет длина массива. Для того, чтобы получить значение последнего элемента применяется следующий подход - длина массива всегда на единицу больше, чем индекс последнего элемента. Используя формулу длина_массива - 1 можно получить значение последнего элемента массива произвольной длины.


// // Стартовый код
// const fruits = ['яблоко', 'персик', 'груша', 'банан'];
// // Пиши код ниже этой строки

// const lastElementIndex = fruits.length - 1;

// const lastElement = fruits[lastElementIndex];     

// задача 9
// Крайние элементы массива

// Напиши функцию getExtremeElements(array) которая принимает один параметр array - массив элементов произвольной длины. Функция должна возвращать массив из двух элементов - первого и последнего элемента параметра array.

// function getExtremeElements(array) {
//   // Пиши код ниже этой строки
  
//   array = [array[0], array[array.length -1]];
//   return array



//   // Пиши код выше этой строки
// }

// console.log(getExtremeElements([1, 2, 3, 4, 5]));

// обратится к функции  и к каждому эллементу массива конкретно, а не ко всему полностью.



// Задача 10
// теория
// Метод split(delimeter) позволяет превратить строку в массив, «разбив» его по разделителю delimeter. Если разделитель это пустая строка, то получится массив отдельных символов. Разделителем может быть один или несколько символов.

// const name = 'Манго';
// console.log(name.split('')); // ['M', 'a', 'н', 'г', 'о']

// const message = 'JavaScript это интересно';
// console.log(message.split(' ')); // ['JavaScript', 'это', 'интересно']
// Задание
// Дополни код функции splitMessage(message, delimeter) так, чтобы она возвращала в переменной words результат разделения строки message по разделителю delimeter массив строк. - 


// function splitMessage(message, delimeter) {
//   let words;
//   // Пиши код ниже этой строки
  
//   words = message.split('');
  
//   // Пиши код выше этой строки
//   return words;
// }
// console.log (splitMessage('Манго спешит на поезд', ' ') );

// function joinMessage(message) {
//   let words;
//   words = message.join('') ;

//   return words
// }
// console.log(joinMessage('mango', 'ajax', 'poly') );

// задача 11

// Гравировка украшений

// Сервису гравировки украшений нужна функция, которая бы автоматически считала цену гравировки, в зависимости от количества слов и цены за слово.

// Объявлена функция calculateEngravingPrice(message, pricePerWord). Эта функция принимает строку, состоящую из слов разделённых только пробелами (параметр message) и цену гравировки одного слова (параметр pricePerWord).

// Напиши тело функции, чтобы она возвращала общую стоимость гравировки всех слов в строке.

// function calculateEngravingPrice(message, pricePerWord) {
//   // Пиши код ниже этой строки
//   return  message.split(' ').length * pricePerWord


  
//   // Пиши код выше этой строки

// }
// console.log(calculateEngravingPrice('JavaScript у меня в крови', 10));
// console.log(calculateEngravingPrice('JavaScript у меня в крови', 20));


// задача 12

// Метод массива join()

// Метод массивов join(delimeter) позволяет соединить элементы массива в строку. В строке элементы будут разделены символом или группой символов указанных в delimeter. То есть это операция обратная методу строк split(delimeter).

// const words = ['JavaScript', 'это', 'интересно'];
// console.log(words.join('')); // 'JavaScriptэтоинтересно'
// console.log(words.join(' ')); // 'JavaScript это интересно'
// console.log(words.join('*')); // 'JavaScript*это*интересно'
// Задание
// Дополни код функции makeStringFromArray(array, delimeter) так, чтобы она возвращала в переменной string результат соединения элементов массива array c разделителем delimeter - строку.


// function makeStringFromArray(array, delimeter) {
//   let string;
//   // Пиши код ниже этой строки
 
//  string = array.join(delimeter);
 
//   // Пиши код выше этой строки
//   return string;
// }

// console.log(makeStringFromArray(['Манго', 'спешит', 'на', 'поезд'], ' '));
// console.log(makeStringFromArray(['лучшее', 'за', 'неделю'], '_'));

// задача 13

// Генератор slug

// Термин slug - это человеко-понятный уникальный идентификатор, который используется в веб-разработке для создания читабельных URL-адесов.

// Например, вместо того чтобы пользователь увидел в адресной строке mysite.com/posts/1q8fh74tx, можно сделать slug из названия статьи. В результате адрес получится более приятным для восприятия: mysite.com/posts/массивы-для-новичков.

// function slugify(title) {
//   // Пиши код ниже этой строки
//  if ( typeof title !== 'string') {
//    return 'fuck you'
//  } else  {
//   title = title.toLowerCase();
//  title = title.split(' ');
 
//   title = title.join('-');

//   return title 
// }
//   // Пиши код выше этой строки
// }
// // console.log(slugify('Английский для разработчика'));
// // console.log(title('Как стать JUNIOR разработчиком за ДВЕ НЕДЕЛИ'));
// console.log(slugify([12, 13,14]));

// задача14

// Метод slice();
// Метод slice(begin, end) возвращает новый массив, содержащий копию части исходного массива, не изменяя его. Копия делается от begin и до, но не включая, end - индексы элементов исходного массива.

// Если begin и end не указаны, будет создана полная копия исходного массива.
// Если не указан end, копирование будет от start и до конца исходного массива.
// Если значение start отрицательное, а end не указан, то будут скопированы последние N элементов.


// const fruits = ['яблоко', 'слива', 'груша', 'апельсин', 'банан'];
// // Пиши код ниже этой строки
// const firstTwoEls = fruits.slice(0, 2);
// const nonExtremeEls = fruits.slice(1,4);
// const lastThreeEls = fruits.slice(-3);
// console.log(firstTwoEls);
// console.log(nonExtremeEls);
// console.log(lastThreeEls);

// задача15

// Метод concat()

// Метод concat используется для объединения двух или более массивов. Он не изменяет массив на котором вызывается, а возвращает новый. Порядок аргументов метода влияет на порядок элементов нового массива.


// const oldClients = ['Манго', 'Аякс', 'Поли', 'Киви'];
// const newClients = ['Персик', 'Хьюстон'];

// const allClients = oldClients.concat(newClients);
//  // Дополни эту строку

//  console.log(allClients);

// задача 16

// Композиция массивов

// Напиши функцию makeArray(firstArray, secondArray, maxLength) для создания нового массива со всеми элементами двух исходных firstArray и secondArray. Параметр maxLength содержит максимально допустимую длину нового массива.

// Если количество элементов нового массива больше maxLength, функция должна вернуть копию массива длиной maxLength элементов.

// В противном случае функция должна вернуть новый массив целиком.

// function makeArray(firstArray, secondArray, maxLength) {
//   // Пиши код ниже этой строки

// const bigArray = firstArray.concat(secondArray).slice(0, maxLength);
//  if (bigArray > bigArray.maxLength) {
//    return bigArray.maxLength 
//  } else {
//    return bigArray
//  }


// }
// console.log(makeArray(['Манго', 'Поли'], ['Аякс', 'Челси'], 3));
// console.log(makeArray(['Манго'], ['Аякс', 'Челси', 'Поли', 'Хьюстон'], 3));
// console.log(makeArray(['Земля', 'Юпитер'], ['Нептун', 'Уран', 'Венера'], 0));


// задача 17

// Цикл for


// Циклы используются для многократного повторения кода. Объявление цикла for состоит из трёх выражений.

// for (Инициализация; Условие; Пост - выражение) {
//   // Тело цикла
// }
// Инициализация - выполняется один раз перед началом цикла. Используется для создания переменной-счётчика и указания её начального значения.
// Условие - выражение, оцениваемое перед каждой итерацией (повторением) цикла. Тело цикла выполняется только тогда, когда выражение приводится к true. Цикл завершается, если значение будет false.
// Пост-выражение - выполняется в конце каждого повторения цикла, перед проверкой условия. Используется для обновления переменной-счётчика.
// Тело - набор инструкций для выполнения на каждом повторении. Выполняется, если выражение условия приводится к true.
// for (let i = 0; i <= 20; i += 5) {
//   console.log(i);
// }
// В примере объявляется переменная i, инициализируется значением 0 и цикл выполняется (его тело) до тех пор, пока i <= 20, то есть условие приводится к true. После каждой итерации счётчик увеличивается на 5.

// const start = 3;
// const end = 7;

// for (let i = start ; i <= end; i += 1 ) { // Дополни эту строку
//   console.log(i);
// }

// задача 18

// Сумма чисел (цикл for)

// Напиши функцию calculateTotal(number), которая принимает целое число (параметр number) и возвращает сумму всех целых чисел от единицы и до этого числа. Например, если number равно 3, то сумма это 1 + 2 + 3, то есть 6.

// function calculateTotal(number) {
// //   // Пиши код ниже этой строки
// let calcTotal = 0;
// let max = number;
// for ( let i = 0; i <= max; i += 1){
//   calcTotal += i;
  
// }
//   return calcTotal
// }
// console.log(calculateTotal(7));





//   // Пиши код выше этой строки

// console.log(calculateTotal(6));

// задача 19


// Цикл for можно использовать для итерации по массиву, то есть «перебрать» его поэлементно.

// const planets = ['Земля', 'Марс', 'Венера'];

// for (let i = 0; i < planets.length; i += 1) {
//   console.log(planets[i]);
// }
// Для доступа к элементам используется синтаксис квадратных скобок массив[индекс], где индекс - это значение счётчика цикла от 0 и до последнего индекса массива, который на единицу меньше длины массива.


// const fruits = ['яблоко', 'слива', 'груша', 'апельсин'];

// for (let i = 0 ; i < fruits.length; i += 1) { // Дополни эту строку
//   const fruit = fruits[i]; // Дополни эту строку
//   console.log(fruit);
// }


// задача 20


// Подсчёт суммы покупки

// Напиши функцию calculateTotalPrice(order), которая принимает один параметр order - массив чисел, и рассчитывает общую сумму его элементов. Общая сумма элементов должна сохраняться в переменной total, которая возвращается, как результат работы функции.

// function calculateTotalPrice(order) {
//   let total = 0;
//   // Пиши код ниже этой строки
// for ( let i = 0; i < order.length; i += 1){
//    total += order[i];
  
// }

//   // Пиши код выше этой строки
//   return total;
// }
// console.log(calculateTotalPrice([12, 85, 37, 4]));
// console.log(calculateTotalPrice([412, 371, 94, 63, 176]));

// задача 21

// Поиск самого длинного слова

// Напиши функцию findLongestWord(string) которая принимает произвольную строку состоящую только из слов разделённых пробелом (параметр string) и возвращает самое длинное слово в этой строке.
// 1 создать for который будет перебирать слова по длинне 
// 2 создать переменную которая будет содержать самое длинное слово
// 3 вернуть переменную

// function findLongestWord(string) {
 
//   // Пиши код ниже этой строки
//   if(typeof string !== 'string') {
//     return
//   }
//   const arrayWords = string.split(' ');
//  let longestWord = arrayWords[0];
//   for( const word of arrayWords ) {
//     if (longestWord.length < word.length) {
//       longestWord = word;
//     } 
  

//   // Пиши код выше этой строки
// }
// return longestWord
// }

// console.log( findLongestWord('The quick brown fox jumped over the lazy dog'));
// console.log(findLongestWord('Google do a roll'));


// function findLongestWord(randomWords) {
//   if (typeof randomWords !== "string") {
//     return;
//   }

//   const splittedWords = randomWords.split(" ");
//   let longestWord = splittedWords[0];

//   for (const word of splittedWords) {
//     if (longestWord.length < word.length) {
//       longestWord = word;
//     }
//   }

//   return longestWord;
// }

// console.log(findLongestWord("Я хочу стать програмистом"));

// задача 22

// Метод push()

// Метод push() позволяет добавить один или несколько элементов в конец массива, без необходимости указывать индексы добавляемых элементов.

// function createArrayOfNumbers(min, max) {
//   const numbers = [];
//   // let Array = (min, max);

//   // Пиши код ниже этой строки
//   for (let i = min; i <= max; i += 1){
//     numbers.push(i);
//   }
 
//   // Пиши код выше этой строки
//   return numbers;
// }
// console.log(createArrayOfNumbers(1, 3));
// console.log(createArrayOfNumbers(29, 34));

// задача 23

// Фильтрация массива чисел

// Напиши функцию filterArray(numbers, value), которая принимает массив чисел (параметр numbers) и возвращает новый массив, в котором будут только те элементы массива numbers, которые больше чем значение параметра value (число).


// function filterArray(numbers, value) {
//   // Пиши код ниже этой строки
// const resultArray = [];

// for( let i = 0; i <= numbers.length; i += 1 ){
//   if (value < numbers[i] ) {
//     resultArray.push(numbers[i]);
//   }
// }
// return resultArray

 
// }
// console.log( filterArray([1, 2, 3, 4, 5], 3));
// console.log(filterArray([12, 24, 8, 41, 76], 20));
//  // Пиши код выше этой строки


// задача 24

// Метод includes()

// Метод includes(value) проверяет есть ли в массиве элемент со значением value и возвращает true или false соответственно. Область применения этого метода сводится к ситуациям, когда необходимо проверить есть ли элемент в массиве и не важна его позиция (индекс).

// const planets = ['Земля', 'Марс', 'Венера'];

// console.log(planets.includes('Земля')); // true
// console.log(planets.includes('земля')); // false
// console.log(planets.includes('Венера')); // true
// console.log(planets.includes('Юпитер')); // false
// Задание
// Функция checkFruit(fruit) принимает строку с названием фрукта (параметр fruit), и проверяет есть ли такой фрукт в массиве fruits.

// Дополни код функции так, что если:

// фрукт есть в массиве, то функция возвращает true;
// фрукта нет в массиве, то функция возвращает false.

// function checkFruit(fruit) {
//   const fruits = ['яблоко', 'слива', 'груша', 'апельсин'];

//   return fruits.includes(fruit); // Дополни эту строку
// }
// console.log( checkFruit('слива'));
// console.log( checkFruit('мандарин'));
// console.log(checkFruit('яблоко'));

// задача 25

// Общие элементы

// Общие элементы
// Задание
// Общими элементами массивов называют те элементы, которые присутствуют во всех массивах.

// Например, в двух массивах [1, 3, 5] и [0, 8, 5, 3] общими будут числа 3 и 5, т.к. они присутствуют в обоих исходных массивах. А числа 0, 1 и 8 присутствуют только в одном из массивов.

// Напиши функцию getCommonElements(array1, array2) которая получает два массива произвольной длины в параметры array1 и array2, и возвращает новый массив, состоящий из тех элементов, которые присутствуют в обоих исходных массивах.

// function getCommonElements(array1, array2) {
//   // Пиши код ниже этой строки
// const array3 = [];
// //  1 нужно проверить первый и второй массивы на одинаковые элементы
// // 2 запушить эти элементы в масив 3
// for (const el of array1) {
//   if (array2.includes(el)){
//     array3.push(el);
//   }
  

// }
//   return array3
//   // Пиши код выше этой строки
// }

// console.log(getCommonElements([1, 2, 3], [2, 4]) );
// console.log(getCommonElements([24, 12, 27, 3], [12, 8, 3, 36, 27]));
// console.log(getCommonElements([10, 20, 30, 40], [4, 30, 17, 10, 40]));


// задача 26 
// Цикл for...of

// Инструкция for...of объявляет цикл, перебирающий итерируемые объекты, такие как массивы и строки. Тело цикла будет выполняться для значения каждого элемента. Это хорошая замена циклу for, если не нужен доступ к счётчику итерации.

// for (const variable of iterable) {
//   // тело цикла
// }
// variable — переменная, которая будет хранить значение элемента на каждой итерации.
// iterable — коллекция, которая имеет перечислимые элементы, например массив.
// const planets = ['Земля', 'Марс', 'Венера'];

// for (const planet of planets) {
//   console.log(planet);
// }
// Задание
// Выполни рефакторинг кода функции calculateTotalPrice(order) заменив цикл for на for...of.

// function calculateTotalPrice(order) {
//   let total = 0;
//   // Пиши код ниже этой строки

//   for (const el of order) {
//     total += el;
//   }

//   // Пиши код выше этой строки
//   return total;
// }

// console.log(calculateTotalPrice([12, 85, 37, 4]) );
// console.log(calculateTotalPrice([412, 371, 94, 63, 176]));
// console.log(calculateTotalPrice([]) );

// задача 27

// Фильтрация массива чисел 2.0

// Выполни рефакторинг функции filterArray(numbers, value) заменив цикл for на for...of.

// function filterArray(numbers, value) {
//   // Пиши код ниже этой строки
//   const filteredNumbers = [];

//   for (const el of numbers) {
//     const number = el;

//     if (number > value) {
//       filteredNumbers.push(number);
//     }
//   }

//   return filteredNumbers;
//   // Пиши код выше этой строки
// }
// console.log(filterArray([1, 2, 3, 4, 5], 3));
// console.log( filterArray([12, 24, 8, 41, 76], 20));

// задача 28

// Оператор %

// Вместо того, чтобы возвращать результат деления, операция по модулю (%) возвращает целочисленный остаток от деления двух чисел - делимого и делителя.

// 5 % 1 = 0
// // 5, разделенное на 1, равно 5, а остаток - 0

// 5 % 2 = 1
// //  5, разделенное на 2, равно 2, а остаток - 1

// 5 % 3 = 2
// //  5, разделенное на 3, равно 1, а остаток - 2

// 5 % 4 = 1
// //  5, разделенное на 4, равно 1, а остаток - 1

// 5 % 5 = 0
// //  5, разделенное на 5, равно 1, а остаток - 0
// Задание
// Дополни выражения остатка от деления так, чтобы код проходил тесты.


// const a = 3 % 1;
// const b = 4 % 3;
// const c = 11 % 4;
// const d = 12 % 7;
// const e = 8 % 3;


// задача 29

// Чётные числа

// Проверка на четность

// function isEven (num) {
//   return num % 2 === 0;
// }
// Задание
// Напиши функцию getEvenNumbers(start, end) которая возвращает массив всех чётных чисел от start до end. Чётным считается число которое делится на 2 без остатка.


// function getEvenNumbers(start, end) {
//   // Пиши код ниже этой строки
// // 1 перебрать масив циклом фор
// // 2найти четные елементы
// // и составить из них масив
// const evenNumbers = [];
// for( let i = start; i <= end; i += 1){
//   if( i %2 === 0) {
//     evenNumbers.push(i);
//   }
// }

//   return evenNumbers
//   // Пиши код выше этой строки
// }
// console.log(getEvenNumbers(3, 11));
// console.log(getEvenNumbers(6, 12) );

// задача 30


// Оператор break

// Прервать выполнение цикла можно в любой момент. Для этого существует оператор break, который полностью прекращает выполнение цикла и передаёт управление на строку за его телом.

// В примере ищем число 3. Как только выполнится условие if, цикл прекратит своё выполнение (будет прерван).

// for (let i = 0; i <= 5; i += 1) {
//   console.log(i);

//   if (i === 3) {
//     console.log('Нашли число 3, прерываем выполнение цикла');
//     break;
//   }
// }

// console.log('Лог после цикла');
// Задание
// Дополни код так, чтобы в переменную number записывалось первое число от start до end, которое делится на 5 без остатка.

// const start = 6;
// const end = 27;
// let number;

// for (let i = start; i < end; i += 1) {
//   if (i % 5 === 0) {
//     number = i;
//     break
//   }
// }


// задача 31

// Оператор break vs return в функции


// Если цикл находится в теле функции, то оператор break не прекращает выполнение функции, а только прервёт цикл. Для того чтобы прерывать выполнение сразу цикла и функции есть оператор return.

// В примере ищем число 3. Как только выполнится условие if, делаем возврат, который прервёт выполнение цикла и функции.

// function fn() {
//   for (let i = 0; i <= 5; i += 1) {
//     console.log(i);

//     if (i === 3) {
//       console.log('Нашли число 3, делаем возврат, прерывая цикл и функцию');
//       return i;
//     }
//   }

//   // Этот console.log не выполнится
//   console.log('Лог после цикла в теле функции');
// }

// const result = fn();
// console.log('Лог после выхода из функции');
// console.lof(`Результат выполнения функции ${result}`);
// Задание
// Выполни рефакторинг функции findNumber(start, end, divisor) так, чтобы она:

// возвращала первое число от start до end, которое делится на divisor без остатка;
// не использовала оператор break;
// не использовала переменную number.

// function findNumber(start, end, divisor) {
//   // Пиши код ниже этой строки
//   let number;

//   for (let i = start; i < end; i += 1) {
//     if (i % divisor === 0) {
//       number = i;
//       break;
//     }
//   }

//   return number;
//   // Пиши код выше этой строки
// }

// function findNumber(start, end, divisor) {
//   // Пиши код ниже этой строки
//   let number;

//   for (let i = start; i < end; i += 1) {
//     if (i % divisor === 0) {
//       number = i;
//       return i;
//     }
//   }

  
//   // Пиши код выше этой строки
// }
// console.log (findNumber(2, 6, 5));
// console.log(findNumber(16, 35, 7));



// задача 32



// Функция includes()


// Напиши функцию includes(array, value), которая делает тоже самое, что и метод массива массив.includes(значение) - проверяет, есть ли в массиве array значение value, возвращая true если есть и false в противном случае.

// При выполнении этой задачи в теле функции includes() нельзя использовать метод массив.includes(значение).

// function includes(array, value) {
//   // Пиши код ниже этой строки
// for( const el of array) {
//   if (el === value) {
//     return true;
//   } {
    
//   }
// }return false;

  
//   // Пиши код выше этой строки
// }
// console.log(includes([1, 2, 3, 4, 5], 3));
// console.log(includes([1, 2, 3, 4, 5], 17) );